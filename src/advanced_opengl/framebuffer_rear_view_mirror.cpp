#include <GLFW/glfw3.h>
#include "../app/shader.h"
#include "../app/application.h"
#include "stb_image.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "../app/utils.h"



float cubeVertices[] = {
    // positions          // texture Coords
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
    0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
    0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
    0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};
float planeVertices[] = {
    // positions          // texture Coords
    5.0f, -0.5f,  5.0f,  2.0f, 0.0f,
    -5.0f, -0.5f,  5.0f,  0.0f, 0.0f,
    -5.0f, -0.5f, -5.0f,  0.0f, 2.0f,

    5.0f, -0.5f,  5.0f,  2.0f, 0.0f,
    -5.0f, -0.5f, -5.0f,  0.0f, 2.0f,
    5.0f, -0.5f, -5.0f,  2.0f, 2.0f
};
float quadVertices[] = { 
    // vertex attributes for a quad that fills the entire screen in Normalized Device Coordinates.
    // NOTE that this plane is now much smaller and at the top of the screen
    // positions   // texCoords
    -0.3f,  1.0f,  0.0f, 1.0f,
    -0.3f,  0.7f,  0.0f, 0.0f,
    0.3f,  0.7f,  1.0f, 0.0f,

    -0.3f,  1.0f,  0.0f, 1.0f,
    0.3f,  0.7f,  1.0f, 0.0f,
    0.3f,  1.0f,  1.0f, 1.0f
};

int main()
{
   Application app("Framebuffer");

   //enable depth testing
   glEnable(GL_DEPTH_TEST);

   // build and compile shader program
   // ------------------------------------
   Shader shader(
           "shaders/frame_buffer/framebuffer_vertx.glsl",
           "shaders/frame_buffer/framebuffer_fs.glsl");
   Shader screenShader(
           "shaders/frame_buffer/framebuffer_screen_vertx.glsl",
           "shaders/frame_buffer/framebuffer_screen_fs.glsl");

   // cube VAO
   unsigned int cubeVAO, cubeVBO;
   glGenVertexArrays(1, &cubeVAO);
   glGenBuffers(1, &cubeVBO);
   glBindVertexArray(cubeVAO);
   glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);
   glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &cubeVertices, GL_STATIC_DRAW);
   glEnableVertexAttribArray(0);
   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
   glEnableVertexAttribArray(1);
   glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
   glBindVertexArray(0);

   // plane VAO
   unsigned int planeVAO, planeVBO;
   glGenVertexArrays(1, &planeVAO);
   glGenBuffers(1, &planeVBO);
   glBindVertexArray(planeVAO);
   glBindBuffer(GL_ARRAY_BUFFER, planeVBO);
   glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), &planeVertices, GL_STATIC_DRAW);
   glEnableVertexAttribArray(0);
   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
   glEnableVertexAttribArray(1);
   glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
   glBindVertexArray(0);

   // screen quad VAO
   unsigned int quadVAO, quadVBO;
   glGenVertexArrays(1, &quadVAO);
   glGenBuffers(1, &quadVBO);
   glBindVertexArray(quadVAO);
   glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
   glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);
   glEnableVertexAttribArray(0);
   glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
   glEnableVertexAttribArray(1);
   glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));


   // load textures
   // -------------
   unsigned int cubeTexture  = loadTexture("resources/textures/container.jpg");
   unsigned int floorTexture = loadTexture("resources/textures/metal.png");
   //stbi_set_flip_vertically_on_load(true);

   // shader configuration
   // --------------------
   shader.use();
   shader.setInt("texture1", 0);

   screenShader.use();
   screenShader.setInt("screenTexture", 0);

   // draw in wireframe
   //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);


   //Framebuffer
   unsigned int framebuffer;
   glGenFramebuffers(1, &framebuffer);
   glBindFramebuffer(GL_FRAMEBUFFER,framebuffer);

   //create color attachment texture
   unsigned int texture;
   glGenTextures(1,&texture);
   glBindTexture(GL_TEXTURE_2D,texture);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
   glBindTexture(GL_TEXTURE_2D,0);
   //attach texture to framebuffer
   glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,texture,0);
   //to attach stencil and depth buffer as one texture t the framebuffer
   //glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0,GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);
   //glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT,GL_TEXTURE_2D, texture, 0);

   //render buffer attachment
   unsigned int rbo;
   glGenRenderbuffers(1,&rbo);
   glBindRenderbuffer(GL_RENDERBUFFER,rbo);
   glRenderbufferStorage(GL_RENDERBUFFER,GL_DEPTH24_STENCIL8,800,600);
   glBindRenderbuffer(GL_RENDERBUFFER, 0);
   //attach rbo to depth and stencil attachment of the framebuffer
   glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT,GL_RENDERBUFFER,rbo);


   if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
   {
       //framebuffer successfully created
       std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!\n";
   }

   glBindFramebuffer(0,framebuffer);
   //glDeleteFramebuffers(1,&framebuffer); //delete framebuffer

   // render loop
   // -----------
   while (!glfwWindowShouldClose(app.window))
   {
       auto currentFrame = static_cast<float>(glfwGetTime());
       app.deltaTime = currentFrame - app.lastFrame;
       app.lastFrame = currentFrame;

       // input
       // -----
       app.processCameraInput();

       // render
       // ------
       glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
       glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
       glEnable(GL_DEPTH_TEST);


       shader.use();
       glm::mat4 model = glm::mat4(1.0f);
       Application::camera.Yaw   += 180.0f; // rotate the camera's yaw 180 degrees around
       Application::camera.ProcessMouseMovement(0, 0, false); // call this to make sure it updates its camera vectors, note that we disable pitch constrains for this specific case (otherwise we can't reverse camera's pitch values)
       glm::mat4 view = Application::camera.GetViewMatrix();
       Application::camera.Yaw   -= 180.0f; // reset it back to its original orientation
       Application::camera.ProcessMouseMovement(0, 0, true);
       glm::mat4 projection = glm::perspective(glm::radians(Application::camera.Zoom), (float)800 / (float)600, 0.1f, 100.0f);
       shader.setMat4("view", view);
       shader.setMat4("projection", projection);

        // floor
        glBindVertexArray(planeVAO);
        glBindTexture(GL_TEXTURE_2D, floorTexture);
        shader.setMat4("model", glm::mat4(1.0f));
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glBindVertexArray(0);

        // cubes
        glBindVertexArray(cubeVAO);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, cubeTexture);
        model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f));
        shader.setMat4("model", model);
        glDrawArrays(GL_TRIANGLES, 0, 36);
        model = glm::mat4(1.0f);
        model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f));
        shader.setMat4("model", model);
        glDrawArrays(GL_TRIANGLES, 0, 36);
        glBindVertexArray(0);


       // second render pass: draw as normal
       // ----------------------------------
       glBindFramebuffer(GL_FRAMEBUFFER, 0);
       glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

       model = glm::mat4(1.0f);
       view = Application::camera.GetViewMatrix();
       shader.setMat4("view", view);

       // cubes
       glBindVertexArray(cubeVAO);
       glActiveTexture(GL_TEXTURE0);
       glBindTexture(GL_TEXTURE_2D, cubeTexture);
       model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f));
       shader.setMat4("model", model);
       glDrawArrays(GL_TRIANGLES, 0, 36);
       model = glm::mat4(1.0f);
       model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f));
       shader.setMat4("model", model);
       glDrawArrays(GL_TRIANGLES, 0, 36);
       // floor
       glBindVertexArray(planeVAO);
       glBindTexture(GL_TEXTURE_2D, floorTexture);
       shader.setMat4("model", glm::mat4(1.0f));
       glDrawArrays(GL_TRIANGLES, 0, 6);
       glBindVertexArray(0);

        glDisable(GL_DEPTH_TEST);
       // glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
       // glClear(GL_COLOR_BUFFER_BIT);

        screenShader.use();
        glBindVertexArray(quadVAO);
        glBindTexture(GL_TEXTURE_2D, texture);	// use the color attachment texture as the texture of the quad plane
        glDrawArrays(GL_TRIANGLES, 0, 6);

       glfwSwapBuffers(app.window);
       glfwPollEvents();
   }
   glDeleteVertexArrays(1, &cubeVAO);
   glDeleteVertexArrays(1, &planeVAO);
   glDeleteVertexArrays(1, &quadVAO);
   glDeleteBuffers(1, &cubeVBO);
   glDeleteBuffers(1, &planeVBO);
   glDeleteBuffers(1, &quadVBO);

   return 0;
}
